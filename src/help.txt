Welcome to Forsp: A Forth+Lisp Hybrid Lambda Calculus Language!

Please find below the list of primitives defined in Forsp:

SPECIAL FORMS: 

Syntax | Parsed as      | Semantics
-------+----------------+------------------------------------------------------
'foo   | quote foo      | The quoted literal (foo) is pushed to the stack
$foo   | quote foo pop  | A value will be popped from the stack and bound to 
       |                | "foo" in the environment
^foo   | quote foo push | The symbol "foo" will be resolved in current 
       |                | environment and pushed to the stack

CORE: Primitives needed to self-implement

primitive [args]    | description                           | example usage
--------------------+---------------------------------------+--------------
push  [$symbol]       | resolve "symbol" in environment and     | 'foo push
                    | push to the top of the stack          |
pop   [$symbol $val]  | bind "val" to "symbol" in environment   | 'foo pop
eq    [$a $b]       | if "a" and "b" are equal, then "t",   | 'a 'b eq
                    | else '()'                             |
cons  [$fst $snd]   | construct a pair from "fst" and "snd" | '(2 3) 1 cons
car   [$pair]       | extract the first element of "pair"   | '(1 2 3) car
cdr   [$pair]       | extract the second element of "pair"  | '(1 2 3) cdr
cswap [$cond $a $b] | if cond is "t" then swap "a" and "b"  | 1 2 't cswap
tag   [$obj]        | query the type-tag of any object      | ^tag tag
read  []            | read an s-expression from input data  | read
print [$obj]        | print an object as an s-expression    | '(foo bar) print

EXTRA: Additional primitives that are not strictly needed, but useful to have

primitive [args]    |  description                          | example usage
--------------------+---------------------------------------+--------------
stack               |  push the "stack" onto the stack:     | stack
                    |  cons'ing self                        |
env                 |  push the "env" onto the stack        | env
+    [$b $a]        |  push the result of 'a+b' (add)       | 3 2 +
-    [$b $a]        |  push the result of 'a-b' (subtract)  | 3 2 -
*    [$b $a]        |  push the result of 'a*b' (multiply)  | 3 2 *
/    [$b $a]        |  push the result of 'a/b' (divide)    | 3 2 /
help                |  print this help page                 | print